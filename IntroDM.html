<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Introduction to Data Manipulation</title>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>

<!-- MathJax scripts -->
<script type="text/javascript" src="https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 { 
   font-size:2.2em; 
}

h2 { 
   font-size:1.8em; 
}

h3 { 
   font-size:1.4em; 
}

h4 { 
   font-size:1.0em; 
}

h5 { 
   font-size:0.9em; 
}

h6 { 
   font-size:0.8em; 
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}

pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * { 
      background: transparent !important; 
      color: black !important; 
      filter:none !important; 
      -ms-filter: none !important; 
   }

   body { 
      font-size:12pt; 
      max-width:100%; 
   }
       
   a, a:visited { 
      text-decoration: underline; 
   }

   hr { 
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote { 
      padding-right: 1em; 
      page-break-inside: avoid; 
   }

   tr, img { 
      page-break-inside: avoid; 
   }

   img { 
      max-width: 100% !important; 
   }

   @page :left { 
      margin: 15mm 20mm 15mm 10mm; 
   }
     
   @page :right { 
      margin: 15mm 10mm 15mm 20mm; 
   }

   p, h2, h3 { 
      orphans: 3; widows: 3; 
   }

   h2, h3 { 
      page-break-after: avoid; 
   }
}
</style>



</head>

<body>
<h1>Introduction to Data Manipulation</h1>

<p>You&#39;ve made it through the theoretical aspects and you&#39;re close to being ready to start getting your hands dirty. All of you have most likely used every single element of this module, but now we will reassess these operators and behaviors to get a deeper understanding - thus allowing us to wield them more effectively.</p>

<h2>Subsetting</h2>

<p>The three subsetting (or subscripting) operators available in R are <code>[</code>, <code>[[</code>, and <code>$</code>. There are also some functions such as <code>subset</code>. Each has different behaviors and caveats attached that are important when deciding which to use for the intended task. </p>

<table><thead>
<tr>
<th>Subscript</th>
<th align="right">Effect</th>
</tr>
</thead><tbody>
<tr>
<td>Positive Numeric Vector</td>
<td align="right">selects items in those indices</td>
</tr>
<tr>
<td>Negative Numeric Vector</td>
<td align="right">selects all but those indices</td>
</tr>
<tr>
<td>Character Vector</td>
<td align="right">selects items with those names</td>
</tr>
<tr>
<td>Logical Vector</td>
<td align="right">selects all TRUE (and NA) items</td>
</tr>
<tr>
<td>Missing</td>
<td align="right">selects all missing</td>
</tr>
</tbody></table>

<p>You can easily see how each of these works given a simple vector</p>

<pre><code class="r">x &lt;- c(1, 5, NA, 8, 10)
names(x) &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;)
x[1]
</code></pre>

<pre><code>## a 
## 1
</code></pre>

<pre><code class="r">x[-1]
</code></pre>

<pre><code>##  b  c  d  e 
##  5 NA  8 10
</code></pre>

<pre><code class="r">x[c(1:3)]
</code></pre>

<pre><code>##  a  b  c 
##  1  5 NA
</code></pre>

<pre><code class="r">x[-c(1:3)]
</code></pre>

<pre><code>##  d  e 
##  8 10
</code></pre>

<pre><code class="r">x[is.na(x)]
</code></pre>

<pre><code>##  c 
## NA
</code></pre>

<pre><code class="r">x[!is.na(x)]
</code></pre>

<pre><code>##  a  b  d  e 
##  1  5  8 10
</code></pre>

<pre><code class="r">x[&quot;b&quot;]
</code></pre>

<pre><code>## b 
## 5
</code></pre>

<pre><code class="r">x[c(&quot;b&quot;, &quot;c&quot;)]
</code></pre>

<pre><code>##  b  c 
##  5 NA
</code></pre>

<pre><code class="r">
# Logical subsetting returns values that you give as true
x[c(TRUE, FALSE, TRUE, FALSE, FALSE)]
</code></pre>

<pre><code>##  a  c 
##  1 NA
</code></pre>

<pre><code class="r"># but don&#39;t forget about the recycling rules!
x[c(TRUE, FALSE)]
</code></pre>

<pre><code>##  a  c  e 
##  1 NA 10
</code></pre>

<pre><code class="r">
# if you call a specific index more than once it will be returned more than
# once
x[c(2, 2)]
</code></pre>

<pre><code>## b b 
## 5 5
</code></pre>

<p>By default, <code>[</code> will simplify the results to the lowest possible dimensionality. That is, it will reduce any higher dimensionality object to a list or vector. This is because if you select a subset, R will coerce the result to the appropriate dimensionality. We will give an example of this momentarily. To stop this behavior you can use the <code>drop = FALSE</code> option.</p>

<p>For higher dimensionality objects, rows and columns are subset individually and can be combined in a single call</p>

<pre><code class="r">Theoph[c(1:10), c(&quot;Time&quot;, &quot;conc&quot;)]
</code></pre>

<pre><code>##     Time  conc
## 1   0.00  0.74
## 2   0.25  2.84
## 3   0.57  6.57
## 4   1.12 10.50
## 5   2.02  9.66
## 6   3.82  8.58
## 7   5.10  8.36
## 8   7.03  7.47
## 9   9.05  6.89
## 10 12.12  5.94
</code></pre>

<p><code>[[</code> and <code>$</code> allow us to take out components of the list.</p>

<p>Likewise, given data frames are lists of column, <code>[[</code> can be used to extract a column from data frames.  </p>

<p><code>[[</code> is similar to <code>[</code>, however, it only returns a single value. <code>$</code> is  shorthand for <code>[[</code> but is only available for character subsetting</p>

<p>There are two additional important distinctions between <code>$</code> and <code>[[</code></p>

<ol>
<li>$ can not be used for column names stored as a variable:</li>
</ol>

<pre><code class="r">id &lt;- &quot;Subject&quot;
Theoph$id
</code></pre>

<pre><code>## NULL
</code></pre>

<pre><code class="r">Theoph[[id]]
</code></pre>

<pre><code>##   [1] 1  1  1  1  1  1  1  1  1  1  1  2  2  2  2  2  2  2  2  2  2  2  3 
##  [24] 3  3  3  3  3  3  3  3  3  3  4  4  4  4  4  4  4  4  4  4  4  5  5 
##  [47] 5  5  5  5  5  5  5  5  5  6  6  6  6  6  6  6  6  6  6  6  7  7  7 
##  [70] 7  7  7  7  7  7  7  7  8  8  8  8  8  8  8  8  8  8  8  9  9  9  9 
##  [93] 9  9  9  9  9  9  9  10 10 10 10 10 10 10 10 10 10 10 11 11 11 11 11
## [116] 11 11 11 11 11 11 12 12 12 12 12 12 12 12 12 12 12
## Levels: 6 &lt; 7 &lt; 8 &lt; 11 &lt; 3 &lt; 2 &lt; 4 &lt; 9 &lt; 12 &lt; 10 &lt; 1 &lt; 5
</code></pre>

<ol>
<li><code>$</code> allows for partial matching</li>
</ol>

<pre><code class="r">names(Theoph)
</code></pre>

<pre><code>## [1] &quot;Subject&quot; &quot;Wt&quot;      &quot;Dose&quot;    &quot;Time&quot;    &quot;conc&quot;
</code></pre>

<pre><code class="r"># $ allows for partial matching
head(Theoph$Sub)
</code></pre>

<pre><code>## [1] 1 1 1 1 1 1
## Levels: 6 &lt; 7 &lt; 8 &lt; 11 &lt; 3 &lt; 2 &lt; 4 &lt; 9 &lt; 12 &lt; 10 &lt; 1 &lt; 5
</code></pre>

<pre><code class="r">head(Theoph$Subj)
</code></pre>

<pre><code>## [1] 1 1 1 1 1 1
## Levels: 6 &lt; 7 &lt; 8 &lt; 11 &lt; 3 &lt; 2 &lt; 4 &lt; 9 &lt; 12 &lt; 10 &lt; 1 &lt; 5
</code></pre>

<pre><code class="r">head(Theoph$Subject)
</code></pre>

<pre><code>## [1] 1 1 1 1 1 1
## Levels: 6 &lt; 7 &lt; 8 &lt; 11 &lt; 3 &lt; 2 &lt; 4 &lt; 9 &lt; 12 &lt; 10 &lt; 1 &lt; 5
</code></pre>

<pre><code class="r">
# &#39;[[&#39; does not
head(Theoph[[&quot;Subj&quot;]])
</code></pre>

<pre><code>## NULL
</code></pre>

<p>Using <code>$</code> can lead to unintended consequences if you&#39;re looking to grab a column of a certain name that isn&#39;t there but a partial match is - especially if this is nested in a function where it isn&#39;t clear immediately</p>

<p><code>[</code> and <code>[[</code> are both useful for different tasks. In a general sense you use them to accomplish the following:</p>

<table><thead>
<tr>
<th></th>
<th>Simplifying</th>
<th>Preserving</th>
</tr>
</thead><tbody>
<tr>
<td>Vector</td>
<td><code>x[[1]]</code></td>
<td><code>x[1]</code></td>
</tr>
<tr>
<td>List</td>
<td><code>x[[1]]</code></td>
<td><code>x[1]</code></td>
</tr>
<tr>
<td>Factor</td>
<td><code>x[1:4, drop = T]</code></td>
<td><code>x[1:4]</code></td>
</tr>
<tr>
<td>Array</td>
<td><code>x[1, ]</code>, <code>x[, 1]</code></td>
<td><code>x[1, , drop = F]</code>, <code>x[, 1, drop = F]</code></td>
</tr>
<tr>
<td>Data frame</td>
<td><code>x[, 1]</code>, <code>x[[1]]</code></td>
<td><code>x[, 1, drop = F]</code>, <code>x[1]</code></td>
</tr>
</tbody></table>

<p>There are benefits for each - simplying is often beneficial when you are looking for a result. Preserving is often beneficial in the programming context when you want to keep the results and structure the same.</p>

<p>An easy way to think about it:</p>

<blockquote>
<p>&ldquo;If list <code>x</code> is a train carrying objects, then <code>x[[5]]</code> is 
the object in car 5; <code>x[4:6]</code> is a train of cars 4-6.&rdquo; &mdash; 
<a href="http://twitter.com/#!/RLangTip/status/118339256388304896">@RLangTip</a></p>
</blockquote>

<p>One thing to note: S3 and S4 objects can override the standard behavior of <code>[</code> and <code>[[</code> so they behave differently for different types of objects. This can be useful for controlling simplification vs preservation behavior.</p>

<h2>LETS LOOK AT SOME EXAMPLES</h2>

<ul>
<li>create a vector, list, and dataframe. </li>
<li>Extract elements using [, [[, and $</li>
<li>What are the type and attributes that remain for the extracted piece of information</li>
<li>Quickly brainstorm a couple situations that these could be important to remember for more complex tasks</li>
</ul>

<h2>Logical Subsetting</h2>

<p>One of the most common ways to subset rows is to use <strong>logical subsetting</strong>. </p>

<p>Let&#39;s take a look</p>

<pre><code class="r">Theoph[Theoph$Subject == 1, ]
</code></pre>

<pre><code>##    Subject   Wt Dose  Time  conc
## 1        1 79.6 4.02  0.00  0.74
## 2        1 79.6 4.02  0.25  2.84
## 3        1 79.6 4.02  0.57  6.57
## 4        1 79.6 4.02  1.12 10.50
## 5        1 79.6 4.02  2.02  9.66
## 6        1 79.6 4.02  3.82  8.58
## 7        1 79.6 4.02  5.10  8.36
## 8        1 79.6 4.02  7.03  7.47
## 9        1 79.6 4.02  9.05  6.89
## 10       1 79.6 4.02 12.12  5.94
## 11       1 79.6 4.02 24.37  3.28
</code></pre>

<p>We just subset the Theoph dataframe to only give us back the rows in which Subject equals 1. How does R go about doing this? Logical subsetting!</p>

<p>Notice what we get when we simply ask for <code>Theoph$Subject == 1</code></p>

<pre><code class="r">Theoph$Subject == 1
</code></pre>

<pre><code>##   [1]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
##  [12] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
##  [23] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
##  [34] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
##  [45] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
##  [56] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
##  [67] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
##  [78] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
##  [89] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
## [100] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
## [111] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
## [122] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
</code></pre>

<p>It doesn&#39;t give us back the values for the rows where subject equals one, rather, it gives us back a vector of <code>TRUE</code> or <code>FALSE</code> values.</p>

<p>So, in reality, we are using the logical subsetting rules to extract the rows of the dataframe that come back <code>TRUE</code> from our logical query.</p>

<p>We can do this &#39;by hand&#39; to show whats going on </p>

<pre><code class="r">subj &lt;- ifelse(Theoph[[&quot;Subject&quot;]] == 1, TRUE, FALSE)
subj
</code></pre>

<pre><code>##   [1]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
##  [12] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
##  [23] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
##  [34] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
##  [45] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
##  [56] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
##  [67] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
##  [78] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
##  [89] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
## [100] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
## [111] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
## [122] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE
</code></pre>

<pre><code class="r">Theoph[subj, ]
</code></pre>

<pre><code>##    Subject   Wt Dose  Time  conc
## 1        1 79.6 4.02  0.00  0.74
## 2        1 79.6 4.02  0.25  2.84
## 3        1 79.6 4.02  0.57  6.57
## 4        1 79.6 4.02  1.12 10.50
## 5        1 79.6 4.02  2.02  9.66
## 6        1 79.6 4.02  3.82  8.58
## 7        1 79.6 4.02  5.10  8.36
## 8        1 79.6 4.02  7.03  7.47
## 9        1 79.6 4.02  9.05  6.89
## 10       1 79.6 4.02 12.12  5.94
## 11       1 79.6 4.02 24.37  3.28
</code></pre>

<p>Logical subsetting is at the core of many of R&#39;s operations. Any time you&#39;re matching, or checking with <code>is.*</code> you are using logical subsetting to test the condition you&#39;re looking for then returning the <code>TRUE</code> results</p>

<h2>Common Subsetting Situations and Some Useful Functions</h2>

<p>Now that you&#39;ve gotten your feet wet with the basics of subsetting, lets check-in with some of the commonly used operators that give us some enhanced subsetting functionality.</p>

<p>Note: These all take advantage of logical subsetting:</p>

<p>Take a moment to prod through to documentation for the other operations. Note for things operations like <code>%in%</code> or <code>&amp;</code> to query help you need to add a single quote around it like so <code>?&#39;%in%&#39;</code></p>

<p>This is a good chance for us to take a deeper look @ both how these functions work and how to read the documentation</p>

<p><strong>pause to look @ %in%, is.na, and which documentation</strong></p>

<ul>
<li><code>%in%</code> </li>
<li><code>is.na</code></li>
<li><code>!</code></li>
<li><code>duplicated</code></li>
<li><code>unique</code></li>
<li><code>&amp;</code></li>
<li><code>|</code></li>
<li><code>which</code></li>
<li><code>any</code></li>
</ul>

<p>It can be useful to make yourself a brief &#39;cheat sheet&#39; of some of the common operations you use to reference when you&#39;re thinking about what you are trying to do what you want your output to be. </p>

<p>For example:</p>

<ul>
<li>%in% - compares values from the input vector with a table vector and returns T/F. 

<ul>
<li>input/output are coerced to vectors and then type-matched before comparison. Factors, lists converted to character vectors!</li>
<li>Never returns NA, making it useful for <code>if</code> conditions</li>
<li>Can be slow for long lists and best avoided for complex cases</li>
</ul></li>
</ul>

<p>There is an interesting nugget of information in the documentation - that the input is coerced to a vector then type-matched. </p>

<p>So what is going on in these two situations?</p>

<pre><code class="r">ISM &lt;- c(TRUE, FALSE, TRUE, FALSE)
ISMnums &lt;- c(1, 0, 1, 0)
SUBJ &lt;- c(1, 2, 3, 4)
ISM %in% SUBJ
</code></pre>

<pre><code>## [1]  TRUE FALSE  TRUE FALSE
</code></pre>

<pre><code class="r">which(ISM %in% SUBJ)
</code></pre>

<pre><code>## [1] 1 3
</code></pre>

<pre><code class="r">ISMnums %in% SUBJ
</code></pre>

<pre><code>## [1]  TRUE FALSE  TRUE FALSE
</code></pre>

<pre><code class="r">which(ISMnums %in% SUBJ)
</code></pre>

<pre><code>## [1] 1 3
</code></pre>

<pre><code class="r">
ISM &lt;- c(TRUE, FALSE, TRUE, FALSE)
SUBJ &lt;- factor(c(1, 2, 3, 4))
ISM %in% SUBJ
</code></pre>

<pre><code>## [1] FALSE FALSE FALSE FALSE
</code></pre>

<pre><code class="r">which(ISM %in% SUBJ)
</code></pre>

<pre><code>## integer(0)
</code></pre>

<pre><code class="r">ISMnums %in% SUBJ
</code></pre>

<pre><code>## [1]  TRUE FALSE  TRUE FALSE
</code></pre>

<pre><code class="r">which(ISMnums %in% SUBJ)
</code></pre>

<pre><code>## [1] 1 3
</code></pre>

<p>hint: look @ ID numbers</p>

<p>The moral of the story, is make sure you know what is going on under the hood - sometimes you can get the &#39;right&#39; answer for the wrong reasons.</p>

<h2>Some Subsetting Practice Problems</h2>

<p>What&#39;s wrong with this subsetting command?
<code>dosingdf &lt;- df[unique(df$ID),]</code></p>

<p>#TO make # quick and easy give harder ones later</p>

<h2>Data Manipulation</h2>

<p>Now that we can slice and dice our data how we want - let&#39;s examine how we can actually manipulate the data</p>

<p>Our goal for this section is to be able to:</p>

<ul>
<li>rename columns systematically</li>
<li>reorder and rearrange rows and columns to our needs</li>
<li>create new columns</li>
</ul>

<h3>renaming columns</h3>

<p>Quick renaming of columns can be easily accomplished using the plyr <code>rename</code> command with the structure:</p>

<p><code>dataframe &lt;- rename(dataframe, c(&quot;oldcolname1&quot; = &quot;newcolname1&quot;, ...))</code></p>

<pre><code class="r">library(plyr)
rename(Theoph, c(Subject = &quot;ID&quot;))
</code></pre>

<pre><code>##     ID   Wt Dose  Time  conc
## 1    1 79.6 4.02  0.00  0.74
## 2    1 79.6 4.02  0.25  2.84
## 3    1 79.6 4.02  0.57  6.57
## 4    1 79.6 4.02  1.12 10.50
## 5    1 79.6 4.02  2.02  9.66
## 6    1 79.6 4.02  3.82  8.58
## 7    1 79.6 4.02  5.10  8.36
## 8    1 79.6 4.02  7.03  7.47
## 9    1 79.6 4.02  9.05  6.89
## 10   1 79.6 4.02 12.12  5.94
## 11   1 79.6 4.02 24.37  3.28
## 12   2 72.4 4.40  0.00  0.00
## 13   2 72.4 4.40  0.27  1.72
## 14   2 72.4 4.40  0.52  7.91
## 15   2 72.4 4.40  1.00  8.31
## 16   2 72.4 4.40  1.92  8.33
## 17   2 72.4 4.40  3.50  6.85
## 18   2 72.4 4.40  5.02  6.08
## 19   2 72.4 4.40  7.03  5.40
## 20   2 72.4 4.40  9.00  4.55
## 21   2 72.4 4.40 12.00  3.01
## 22   2 72.4 4.40 24.30  0.90
## 23   3 70.5 4.53  0.00  0.00
## 24   3 70.5 4.53  0.27  4.40
## 25   3 70.5 4.53  0.58  6.90
## 26   3 70.5 4.53  1.02  8.20
## 27   3 70.5 4.53  2.02  7.80
## 28   3 70.5 4.53  3.62  7.50
## 29   3 70.5 4.53  5.08  6.20
## 30   3 70.5 4.53  7.07  5.30
## 31   3 70.5 4.53  9.00  4.90
## 32   3 70.5 4.53 12.15  3.70
## 33   3 70.5 4.53 24.17  1.05
## 34   4 72.7 4.40  0.00  0.00
## 35   4 72.7 4.40  0.35  1.89
## 36   4 72.7 4.40  0.60  4.60
## 37   4 72.7 4.40  1.07  8.60
## 38   4 72.7 4.40  2.13  8.38
## 39   4 72.7 4.40  3.50  7.54
## 40   4 72.7 4.40  5.02  6.88
## 41   4 72.7 4.40  7.02  5.78
## 42   4 72.7 4.40  9.02  5.33
## 43   4 72.7 4.40 11.98  4.19
## 44   4 72.7 4.40 24.65  1.15
## 45   5 54.6 5.86  0.00  0.00
## 46   5 54.6 5.86  0.30  2.02
## 47   5 54.6 5.86  0.52  5.63
## 48   5 54.6 5.86  1.00 11.40
## 49   5 54.6 5.86  2.02  9.33
## 50   5 54.6 5.86  3.50  8.74
## 51   5 54.6 5.86  5.02  7.56
## 52   5 54.6 5.86  7.02  7.09
## 53   5 54.6 5.86  9.10  5.90
## 54   5 54.6 5.86 12.00  4.37
## 55   5 54.6 5.86 24.35  1.57
## 56   6 80.0 4.00  0.00  0.00
## 57   6 80.0 4.00  0.27  1.29
## 58   6 80.0 4.00  0.58  3.08
## 59   6 80.0 4.00  1.15  6.44
## 60   6 80.0 4.00  2.03  6.32
## 61   6 80.0 4.00  3.57  5.53
## 62   6 80.0 4.00  5.00  4.94
## 63   6 80.0 4.00  7.00  4.02
## 64   6 80.0 4.00  9.22  3.46
## 65   6 80.0 4.00 12.10  2.78
## 66   6 80.0 4.00 23.85  0.92
## 67   7 64.6 4.95  0.00  0.15
## 68   7 64.6 4.95  0.25  0.85
## 69   7 64.6 4.95  0.50  2.35
## 70   7 64.6 4.95  1.02  5.02
## 71   7 64.6 4.95  2.02  6.58
## 72   7 64.6 4.95  3.48  7.09
## 73   7 64.6 4.95  5.00  6.66
## 74   7 64.6 4.95  6.98  5.25
## 75   7 64.6 4.95  9.00  4.39
## 76   7 64.6 4.95 12.05  3.53
## 77   7 64.6 4.95 24.22  1.15
## 78   8 70.5 4.53  0.00  0.00
## 79   8 70.5 4.53  0.25  3.05
## 80   8 70.5 4.53  0.52  3.05
## 81   8 70.5 4.53  0.98  7.31
## 82   8 70.5 4.53  2.02  7.56
## 83   8 70.5 4.53  3.53  6.59
## 84   8 70.5 4.53  5.05  5.88
## 85   8 70.5 4.53  7.15  4.73
## 86   8 70.5 4.53  9.07  4.57
## 87   8 70.5 4.53 12.10  3.00
## 88   8 70.5 4.53 24.12  1.25
## 89   9 86.4 3.10  0.00  0.00
## 90   9 86.4 3.10  0.30  7.37
## 91   9 86.4 3.10  0.63  9.03
## 92   9 86.4 3.10  1.05  7.14
## 93   9 86.4 3.10  2.02  6.33
## 94   9 86.4 3.10  3.53  5.66
## 95   9 86.4 3.10  5.02  5.67
## 96   9 86.4 3.10  7.17  4.24
## 97   9 86.4 3.10  8.80  4.11
## 98   9 86.4 3.10 11.60  3.16
## 99   9 86.4 3.10 24.43  1.12
## 100 10 58.2 5.50  0.00  0.24
## 101 10 58.2 5.50  0.37  2.89
## 102 10 58.2 5.50  0.77  5.22
## 103 10 58.2 5.50  1.02  6.41
## 104 10 58.2 5.50  2.05  7.83
## 105 10 58.2 5.50  3.55 10.21
## 106 10 58.2 5.50  5.05  9.18
## 107 10 58.2 5.50  7.08  8.02
## 108 10 58.2 5.50  9.38  7.14
## 109 10 58.2 5.50 12.10  5.68
## 110 10 58.2 5.50 23.70  2.42
## 111 11 65.0 4.92  0.00  0.00
## 112 11 65.0 4.92  0.25  4.86
## 113 11 65.0 4.92  0.50  7.24
## 114 11 65.0 4.92  0.98  8.00
## 115 11 65.0 4.92  1.98  6.81
## 116 11 65.0 4.92  3.60  5.87
## 117 11 65.0 4.92  5.02  5.22
## 118 11 65.0 4.92  7.03  4.45
## 119 11 65.0 4.92  9.03  3.62
## 120 11 65.0 4.92 12.12  2.69
## 121 11 65.0 4.92 24.08  0.86
## 122 12 60.5 5.30  0.00  0.00
## 123 12 60.5 5.30  0.25  1.25
## 124 12 60.5 5.30  0.50  3.96
## 125 12 60.5 5.30  1.00  7.82
## 126 12 60.5 5.30  2.00  9.72
## 127 12 60.5 5.30  3.52  9.75
## 128 12 60.5 5.30  5.07  8.57
## 129 12 60.5 5.30  7.07  6.59
## 130 12 60.5 5.30  9.03  6.11
## 131 12 60.5 5.30 12.05  4.57
## 132 12 60.5 5.30 24.15  1.17
</code></pre>

<p>This can also be done directly without plyr, however is a bit more verbose</p>

<pre><code class="r">names(Theoph)[names(Theoph) == &quot;Subject&quot;] &lt;- &quot;ID&quot;
</code></pre>

<p>Pause for a second - given what we&#39;ve learned about subsetting - what is going on based on the way we&#39;ve constructed the renaming.</p>

<p>Answer: <code>names(Theoph)</code> creates a vector of names - the <code>names(Theoph) == &quot;Subject&quot;</code> logically subsets the vector to identify which index matches the query. <code>&lt;- &quot;ID&quot;</code> is to assign a new value to that index location(s).</p>

<p>Column names can be directly accessed using the <code>colnames</code> function (or for dataframes or lists simply <code>names</code>), and you can rename them all directly by giving it a vector of names. </p>

<pre><code class="r">colnames(Theoph) &lt;- c(&quot;hello&quot;, &quot;there&quot;)
colnames(Theoph)
</code></pre>

<pre><code>## [1] &quot;hello&quot; &quot;there&quot; NA      NA      NA
</code></pre>

<pre><code class="r">rm(Theoph)
</code></pre>

<p>As you can see, this can be dangerous due to not giving the proper length vector (remember R&#39;s recycling rule!), likewise, if the order of columns changes unexpectedly, your vector could rename columns incorrectly.</p>

<p>There are a couple things directly accessing all the colnames can be useful for though.</p>

<p>For example, capitalization of columns can often be inconsistent and frustrating. This can be quickly fixed by converting all columns to uppercase or lowercase using <code>toupper()</code> and <code>tolower()</code></p>

<pre><code class="r">names(Theoph)
</code></pre>

<pre><code>## [1] &quot;Subject&quot; &quot;Wt&quot;      &quot;Dose&quot;    &quot;Time&quot;    &quot;conc&quot;
</code></pre>

<pre><code class="r">names(Theoph) &lt;- toupper(names(Theoph))
names(Theoph)
</code></pre>

<pre><code>## [1] &quot;SUBJECT&quot; &quot;WT&quot;      &quot;DOSE&quot;    &quot;TIME&quot;    &quot;CONC&quot;
</code></pre>

<pre><code class="r">rm(Theoph)
</code></pre>

<h3>reordering rows/columns</h3>

<p>When reordering columns in a dataframe you can actually think of it as creating a new dataframe in which the columns get created in the way you order them.</p>

<pre><code class="r">newTheoph &lt;- Theoph[c(&quot;Subject&quot;, &quot;Time&quot;, &quot;conc&quot;, &quot;Dose&quot;, &quot;Wt&quot;)]
head(Theoph)
</code></pre>

<pre><code>##   Subject   Wt Dose Time  conc
## 1       1 79.6 4.02 0.00  0.74
## 2       1 79.6 4.02 0.25  2.84
## 3       1 79.6 4.02 0.57  6.57
## 4       1 79.6 4.02 1.12 10.50
## 5       1 79.6 4.02 2.02  9.66
## 6       1 79.6 4.02 3.82  8.58
</code></pre>

<pre><code class="r">head(newTheoph)
</code></pre>

<pre><code>##   Subject Time  conc Dose   Wt
## 1       1 0.00  0.74 4.02 79.6
## 2       1 0.25  2.84 4.02 79.6
## 3       1 0.57  6.57 4.02 79.6
## 4       1 1.12 10.50 4.02 79.6
## 5       1 2.02  9.66 4.02 79.6
## 6       1 3.82  8.58 4.02 79.6
</code></pre>

<p>Most of the time since you don&#39;t want to create a new data frame every time you reorder, you can simply overwrite the old data frame. <code>Theoph &lt;- Theoph[c(&quot;Subject&quot;, &quot;Time&quot;, &quot;conc&quot;, &quot;Dose&quot;, &quot;Wt&quot;)]</code></p>

<p>Just like all other subsetting we&#39;ve gone over, we can also organize by index</p>

<p><code>Theoph &lt;- Theoph[c(1, 4, 5, 3, 2)]</code></p>

<p>I suggest against it unless you have good reason. (ie you know your code will always be a specific structure) Even then, while faster to type than named indices, it makes legibility more difficult, and modification down the line more tedious trying to keep track.</p>

<h3>Keys</h3>

<p>Similar to columns, rows also have names. As you slice and dice and reorder a dataset it can get pretty ugly, so if the need arises, row names can be rest by <code>rownames(df) &lt;- NULL</code></p>

<p>Rows can always be referred by their name. They are also structurally distinguishable by their content. </p>

<p>A <strong>key</strong> is the set of columns that can uniquely distinguish every row. Different datasets can have keys of varying complexity (number of columns)</p>

<p>A basic dosing dataset key may be as simple as ID, however for a cross-over clinical trial a dataset may be keyed on ID, time, and cohort. </p>

<p>The general relationship between <strong>key columns</strong> and other columns is:</p>

<blockquote>
<p>Key columns should represent unique objects (persons, events) and the other columns should characterize these objects</p>
</blockquote>

<p>R does not explicitly recognize keys - it is up to keep track.</p>

<h3>Ordering and expand.grid()</h3>

<p>The concept of keys can help us think about the structure of the dataset when we deal with ordering.</p>

<p>The <code>order</code> function in R allows us to easily sort data in ascending or descending order.</p>

<p>If we wanted to sort a dataset by ID and Time we could do so via:</p>

<p><code>df &lt;- df[order(df$ID, df$Time),]</code></p>

<p>It is a good habit to sort raw data (especially if its eventually going into phoenix or nonmem)</p>

<p>The way <code>order</code> works with multiple arguments is it sorts starting with the first argument, each time it runs into a &#39;tie&#39; it looks for subsequent arguments for how to break the &#39;tie&#39;</p>

<p>For example, if you have 5 time observations associated with an ID, if you do:
<code>order(df$ID, df$TIME)</code> it will start sorting by <code>ID</code>, notice it has multiple results for the same ID value, it will then use <code>TIME</code> to continue the sort.</p>

<p><code>order</code> is quite powerful with the <code>expand.grid</code> function. </p>

<h3>Additional manipulations</h3>

<p>To quickly note - columns and rows can be removed simply by calling their index and assigning it to NULL</p>

<p><code>Theoph$Subject &lt;- NULL</code> or <code>Theoph[Theoph$Subject ==1,] &lt;- NULL</code></p>

<p><code>with</code> - &#39;opens up&#39; the input within the function to allow us access columns similar to <code>attach()</code> but only in the function&#39;s temporary environment. Can be very useful for with modeling.</p>

<pre><code class="r">## get better example
library(MASS)
with(anorexia, {
    anorex.1 &lt;- glm(Postwt ~ Prewt + Treat + offset(Prewt), family = gaussian)
    summary(anorex.1)
})
</code></pre>

<pre><code class="r">with(Theoph, summary(conc))
</code></pre>

<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##    0.00    2.88    5.28    4.96    7.14   11.40
</code></pre>

<pre><code class="r"># same as
summary(Theoph$conc)
</code></pre>

<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##    0.00    2.88    5.28    4.96    7.14   11.40
</code></pre>

<p><code>within</code> - allows us access inside a data structure to do things <em>within</em> it</p>

<pre><code class="r">id_time &lt;- data.frame(expand.grid(ID = 1:3, TIME = 0:10))
head(id_time)
</code></pre>

<pre><code>##   ID TIME
## 1  1    0
## 2  2    0
## 3  3    0
## 4  1    1
## 5  2    1
## 6  3    1
</code></pre>

<pre><code class="r">id_time &lt;- id_time[order(id_time$ID, id_time$TIME), ]
head(id_time)
</code></pre>

<pre><code>##    ID TIME
## 1   1    0
## 4   1    1
## 7   1    2
## 10  1    3
## 13  1    4
## 16  1    5
</code></pre>

<pre><code class="r">df &lt;- within(id_time, {
    DV &lt;- 0
    AMT &lt;- 0
    DOSE &lt;- 150
    MDV &lt;- 0
})
head(df)
</code></pre>

<pre><code>##    ID TIME MDV DOSE AMT DV
## 1   1    0   0  150   0  0
## 4   1    1   0  150   0  0
## 7   1    2   0  150   0  0
## 10  1    3   0  150   0  0
## 13  1    4   0  150   0  0
## 16  1    5   0  150   0  0
</code></pre>

<p>ie will have column order MDV, DOSE, AMT, DV add by column from bottom up going outward</p>

<p>**notice the structure of a <code>within</code> call, there are no <code>,</code>s inside the brackets when creating multiple columns</p>

<p>Let&#39;s try to create a simulation data frame</p>

<pre><code class="r">df &lt;- data.frame(ID = 1:5)
df &lt;- within(df, {
    UCTX &lt;- 0
    # initialize amount to NA so will be read in as blank to phoenix
    AMT &lt;- NA
    # initialize doses
    DOSE &lt;- numeric()
    ADDL &lt;- NA
    II &lt;- NA
})
str(df)
</code></pre>

<pre><code>## &#39;data.frame&#39;:    5 obs. of  6 variables:
##  $ ID  : int  1 2 3 4 5
##  $ II  : logi  NA NA NA NA NA
##  $ ADDL: logi  NA NA NA NA NA
##  $ DOSE: num  NA NA NA NA NA
##  $ AMT : logi  NA NA NA NA NA
##  $ UCTX: num  0 0 0 0 0
</code></pre>

<p>Check out the differences between AMT/ADDL/II columns and DOSE</p>

<p><code>within</code> can also be used for logical subsetting in a concisely written format:</p>

<pre><code class="r">Theoph$MDV &lt;- 1
Theoph &lt;- within(Theoph, MDV[Subject == 2 &amp; conc == 0] &lt;- 0)
</code></pre>

<h2>Assignments</h2>

<ul>
<li>using <code>expand.grid</code> and <code>order</code> create an <code>id_time</code> dataset (dataframe)</li>
<li>within the dataset add another column <code>Measurement</code> that is a set of noise generated with <code>rnorm</code> or <code>runif</code></li>
<li>use <code>with</code> to subset Theoph for ID&#39;s 1 and 2 only</li>
<li>generate a new conc column for Theoph</li>
</ul>

<h2>Merging Data</h2>

<p>Let&#39;s create some sample data to merge</p>

<p>TOCHANGE: modify sample merge data off metrum-esque</p>

<pre><code class="r">dose &lt;- data.frame(subject = rep(letters[1:3], each = 2), time = rep(c(1, 3), 
    3), amount = rep(c(40, 60, 80), each = 2))

pk &lt;- data.frame(subject = rep(letters[1:3], each = 4), time = rep(1:4, 3), 
    conc = signif(rnorm(12), 2) + 2)

demo &lt;- data.frame(subject = letters[1:4], race = c(&quot;asian&quot;, &quot;white&quot;, &quot;black&quot;, 
    &quot;other&quot;), sex = c(&quot;female&quot;, &quot;male&quot;, &quot;female&quot;, &quot;male&quot;), weight = c(75, 70, 
    73, 68))
</code></pre>

<p>You can merge two data frames with the <code>merge</code> command. Merge looks for <strong>keys</strong> to match up which rows and columns can be matched. <code>merge</code> can only combine two data frames at once, so in order to merge more than that, nested <code>merge</code> calls must be used</p>

<p>What is the order of merging here?</p>

<pre><code>merge(merge(x, y), z)
</code></pre>

<p>Let&#39;s look at some of the merge options</p>

<p><code>?merge</code></p>

<p>Can do more advanced merges - lets merge everything but not include demographic data from subject 3</p>

<pre><code class="r">merge(merge(dose, pk, all = TRUE), demo[-3, ], all.x = TRUE)
</code></pre>

<pre><code>##    subject time amount  conc  race    sex weight
## 1        a    1     40 3.700 asian female     75
## 2        a    2     NA 2.048 asian female     75
## 3        a    3     40 2.650 asian female     75
## 4        a    4     NA 3.400 asian female     75
## 5        b    1     60 2.400 white   male     70
## 6        b    2     NA 1.060 white   male     70
## 7        b    3     60 3.100 white   male     70
## 8        b    4     NA 1.250 white   male     70
## 9        c    1     80 1.580  &lt;NA&gt;   &lt;NA&gt;     NA
## 10       c    2     NA 1.180  &lt;NA&gt;   &lt;NA&gt;     NA
## 11       c    3     80 2.410  &lt;NA&gt;   &lt;NA&gt;     NA
## 12       c    4     NA 2.610  &lt;NA&gt;   &lt;NA&gt;     NA
</code></pre>

</body>

</html>
